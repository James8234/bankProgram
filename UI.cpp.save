#include "UI.h"

void screenResize(WINDOW *&win, )
{
		// checks if the screen has changed
		int ymax, xmax;
		int copy = xmax;
		getmaxyx(stdscr, ymax, xmax);

		if(xmax != copy)
		{
			delwin(win); // cleans the memroy for the old window
			win = newwin(ymax, xmax, 0, 0);
			box(win, 0 ,0);
			keypad(win, true); //changes the size may lose keypad so it needs to be called again
		}
}


int printMainMenu()
{
	//starts ncurses
	initscr();

	raw(); // makes input raw
	noecho(); // removes the user input from being visable
	cbreak();

	int ymax, xmax;
	int position = 0;

	int c;


	//gets the screen size
	getmaxyx(stdscr, ymax, xmax);

	WINDOW *win = newwin(ymax, xmax, 0, 0); // makes the window
	refresh(); // refreash the screen so it knows we made a window

	box(win, 0 ,0);

	const string s1 = "Welcome! Choose an option";
	const string s2 = "0. Exit Program";
	const string s3 = "1. Login";
	const string s4 = "Enter Up arrow or down arrow and enter -->:";

	//checks if the computer supports colors
	if(!has_colors())
	{
		printw("terminal dose not support color");
		getch();
		werase(win);
		delwin(win); //clean up
		endwin();
		exit(0);
	}

	//starts the color
	start_color();
	init_pair(1, COLOR_WHITE, COLOR_BLUE);

	// enable arrows
	keypad(win, true);

	while(true)
	{

		screenResize(win);
/*
		// checks if the screen has changed
		copy = xmax;
		getmaxyx(stdscr, ymax, xmax);

		if(xmax != copy)
		{
			delwin(win); // cleans the memroy for the old window
			win = newwin(ymax, xmax, 0, 0);
			box(win, 0 ,0);
			keypad(win, true); //changes the size may lose keypad so it needs to be called again
		}
*/
		// prints the UI
		mvwprintw(win, 1, ((xmax - s1.size())/2) , s1.c_str()); //.c_str() converts string to const *char

		if(position == 0)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 3,(( xmax - s2.size())/2), s2.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 3, ((xmax - s2.size())/2), s2.c_str());
		}

		if(position == 1)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 4, ((xmax - s3.size())/2) , s3.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 4, ((xmax -s3.size())/2), s3.c_str());
		}

		mvwprintw(win, 6, ((xmax - s4.size())/2), s4.c_str());
		wrefresh(win); //updates the information

		//int c = wgetch(win);

		// this is ture when the user enters enter
		if(c == KEY_ENTER || c == '\r' || c == '\n')
		{
	//		mvwprintw(win, 8, 12, "exit");
	//		wrefresh(win);
	//		getch();
			werase(win); // clear the contents of the window
//			wrefresh(win);
			delwin(win); //delete the window
			endwin();
			return position;
		}

		c = wgetch(win);

		// This decrements the position
		if(c == KEY_UP && position > 0)
		{
			position--;
		}

		// This increments the position
		if(c == KEY_DOWN && position < 1)
		{
			position++;
		}

	}

}


// this function will print the login UI 
int printLoginAccount(string& usr, string& pass) //prints the ui
{
	initscr();

	raw();
	noecho(); // removes the user input from being visable
	cbreak();

	// position variables
	int ymax, xmax;
	int position = 0;
	int copy;

	char ch;
	int c;

	// UI variables
	const string s1 = "Login page";
	const string s2 = "0. Exit Program";
	const string s3 = "1. Enter Username: ";
	const string s4 = "2. Enter Password: ";
	const string s5 = "3. Enter ";
	const string s6 = "Press enter to push data -->:";

	/* This functions create the screen and box */
	getmaxyx(stdscr, ymax, xmax); //gets the screen size
	WINDOW *win = newwin(ymax, xmax, 0, 0); // makes the window
	refresh(); // refreash the screen so it knows we made a window
	box(win, 0 ,0);


	//checks if the computer supports colors
	if(!has_colors())
	{
		printw("terminal dose not support color");
		getch();
		werase(win); //clear printed data
		delwin(win); //clean up
		endwin();
		exit(0);
	}

	//starts the color - seleced color
	start_color();
	init_pair(1, COLOR_WHITE, COLOR_BLUE);
	init_pair(2, COLOR_GREEN, COLOR_BLUE);
	// enable arrows
	keypad(win, true);



	while(true)
	{
		// checks if the screen has changed
		copy = xmax;
		getmaxyx(stdscr, ymax, xmax);

		if(xmax != copy)
		{
			delwin(win); // cleans the memroy for the old window
			win = newwin(ymax, xmax, 0, 0);
			box(win, 0 ,0);
			keypad(win, true); //changes the size may lose keypad so it needs to be called again
		}

		// prints the UI
		mvwprintw(win, 1, ((xmax - s1.size())/2) , s1.c_str()); //.c_str() converts string to const *char

		if(position == 0)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 3, ((xmax - s2.size())/2), s2.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 3, ((xmax - s2.size())/2), s2.c_str());
		}

		if(position == 1)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 4, ((xmax - s3.size())/2) , s3.c_str());
			mvwprintw(win, 4, (((xmax - s3.size())/2) + s3.size()), usr.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 4, ((xmax  - s3.size())/2), s3.c_str());
			mvwprintw(win, 4, (((xmax - s3.size())/2) + s3.size()), usr.c_str());
		}

		if(position == 2)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 5, ((xmax - s4.size())/2) , s4.c_str());
			mvwprintw(win, 5, (((xmax - s4.size())/2) + s4.size()), pass.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 5, ((xmax -s4.size())/2), s4.c_str());
			mvwprintw(win, 5, (((xmax - s4.size())/2) + s4.size()), pass.c_str());
		}

		if(position == 3)
		{
			wattron(win, COLOR_PAIR(1));
			mvwprintw(win, 6, ((xmax - s5.size())/2) , s5.c_str());
			wattroff(win, COLOR_PAIR(1)); // turns off the color pair after use
		}
		else
		{
			mvwprintw(win, 6, ((xmax - s5.size())/2), s5.c_str());
		}

		mvwprintw(win, 8, ((xmax - s6.size())/2), s6.c_str());
		wrefresh(win); //updates the information


		// this is ture when the user enters enter
		if(c == KEY_ENTER || c == '\r' || c == '\n')
		{
			if(position == 0 || position == 3)
			{
				werase(win); // clear the contents of the window
				delwin(win); //delete the window
				endwin();
				return position;
			}


			//this statment gets the username
			if(position == 1 && (c == KEY_ENTER || c == '\r' || c == '\n'))
			{
				//let the uesr know they selected the line
				wattron(win, COLOR_PAIR(2));
				mvwprintw(win, 4, ((xmax - s3.size())/2) , s3.c_str());
				mvwprintw(win, 4, (((xmax - s3.size())/2) + s3.size()), usr.c_str());
				wattroff(win, COLOR_PAIR(2));
				wrefresh(win);

				while((ch = getch()) != '\n')
				{
					// update the UI

					if(ch == 127) //127 is for back /
					{
						if(!usr.empty())
						{
							usr.pop_back(); //removes the letter
						}
					}
					else
					{
						usr.push_back(ch);
					}//else

					wattron(win, COLOR_PAIR(2));
					mvwprintw(win, 4, ((xmax - s3.size())/2) , s3.c_str());
					mvwprintw(win, 4, (((xmax - s3.size())/2) + s3.size()), usr.c_str());
					wattroff(win, COLOR_PAIR(2));
					wrefresh(win);

				}//while
			} //if(position = 1 && (c == KEY_ENTER || c == '\r' || c == '\n'))

			//this statment gets the password
			if(position == 2 && (c == KEY_ENTER || c == '\r' || c == '\n'))
			{
				//let the use know they have selected the line
				wattron(win, COLOR_PAIR(2));
				mvwprintw(win, 5, ((xmax - s4.size())/2) , s4.c_str());
				mvwprintw(win, 5, (((xmax - s4.size())/2) + s4.size()), pass.c_str());
				wattroff(win, COLOR_PAIR(2));
				wrefresh(win);

				while((ch = getch()) != '\n')
				{

					if(ch == 127) //127 is for back /
					{
						if(!pass.empty())
						{
							pass.pop_back(); //removes the letter
						}
					}
					else
					{
						pass.push_back(ch);
					}
					wattron(win, COLOR_PAIR(2));
					mvwprintw(win, 5, ((xmax - s4.size())/2) , s4.c_str());
					mvwprintw(win, 5, (((xmax - s4.size())/2) + s4.size()), pass.c_str());
					wattroff(win, COLOR_PAIR(2));
					wrefresh(win);
				}//while
			} //if(position = 1 && (c == KEY_ENTER || c == '\r' || c == '\n'))

		} //if(c == KEY_ENTER || c == '\r' || c == '\n')

		c = wgetch(win);

		// This decrements the position
		if(c == KEY_UP && position > 0)
		{
			position--;
			wrefresh(win);
		}

		// This increments the position
		if(c == KEY_DOWN && position < 3)
		{
			position++;
			wrefresh(win);
		}



	} //while

}
